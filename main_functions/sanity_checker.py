# -*- coding: utf-8 -*-
"""
Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12uxWxkEzk3Yw4oFL6Hrw9kxKGCOMp8LD
"""

import pandas as pd
import numpy as np
import seaborn as sns

from sklearn.datasets import make_classification
from scipy.stats import ks_2samp

from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier

from sklearn.model_selection import StratifiedKFold
from sklearn.model_selection import train_test_split, TimeSeriesSplit
from sklearn.metrics import accuracy_score

from math import ceil, floor

import matplotlib.pyplot as plt
import matplotlib.backends.backend_pdf

class Distribution_Comparator():

  def __init__(self, seed, n_splits, alpha=.05, export_results=False, base_model=DecisionTreeClassifier(max_depth=5)):

    self.seed= seed
    self.n_splits=n_splits
    self.alpha=alpha
    self.export_results = export_results
    self.base_model = base_model
    self.counter = 0
    self.colors = ['y','r','b','g']

  def fit(self, df1, df2):

    assert isinstance(df1,pd.DataFrame), 'df1 must be a DataFrame'
    assert isinstance(df2,pd.DataFrame), 'df2 must be a DataFrame'
    assert df1.columns.tolist()==df2.columns.tolist(), 'X1 and X2 must have the same columns'

    self.df1=df1
    self.df2=df2

  def export_as_pdf_init(self,filename):
    pdf = matplotlib.backends.backend_pdf.PdfPages(filename + ".pdf")
    self.pdf = pdf

  def export_as_pdf_save_image(self,fig):
    self.pdf.savefig(fig)

  def export_as_pdf_close(self):
    self.pdf.close()

  def plot_distributions(self, kind):

    assert kind in ['ecdf', 'histogram', 'boxplot','violin'], 'kind must be "ecdf", "histogram","boxplot" or "violin"'

    p = self.df1.shape[1]
    m1 = self.df1.shape[0]
    m2 = self.df2.shape[0]

    init=0
    end=9

    if self.export_results:
      self.export_as_pdf_init(kind)

    for iteration in range(int(p/9)+1):

      fig, axis = plt.subplots(3, 3, figsize=(20,10))

      for column, ax  in zip(self.df1.columns[init:end], axis.ravel()):

        if kind == 'ecdf':
          ax.plot(np.arange(1/m1,1 + 1/m1, 1/m1), self.df1[column].sort_values(), color='blue', label='set 1')
          ax.plot(np.arange(1/m2,1 + 1/m2, 1/m2), self.df2[column].sort_values(), color='red', label='set 2')

        elif kind=='histogram':
          stat = 'proportion'
          sns.histplot(self.df1[column], color='blue', label='set 1', alpha=.5, stat=stat, ax=ax)
          # ax.vlines(self.df1[column].mean(), color='blue', ymin=0 , ymax=m1*.2)
          sns.histplot(self.df2[column], color='red', label='set 2', alpha=.5, stat=stat, ax=ax)
          # ax.vlines(self.df2[column].mean(), color='red', ymin=0 , ymax=m2*.2)

        elif kind=='boxplot':
          aux = pd.concat([self.df1[[column]].assign(data = 'set 1'),self.df2[[column]].assign(data = 'set 2')], axis=0)
          sns.boxplot(x=column, y='data', data=aux, ax=ax)
          # sns.swarmplot(x=column, y='data', data=aux, color=".25", ax=ax)

        elif kind=='violin':
          aux = pd.concat([self.df1[[column]].assign(data = 'set 1'),self.df2[[column]].assign(data = 'set 2')], axis=0)
          sns.violinplot(x=column, y='data',  data=aux, cut = 0, ax=ax)
          ax.set_xlabel('values')
          ax.set_title("column")


        ax.set_title(column)
        if kind in ['histogram', 'ecdf']:
          ax.legend()

      plt.tight_layout()
      plt.show()

      if self.export_results:
        self.export_as_pdf_save_image(fig)

      init+=9
      end+=9
  
    if self.export_results:
      self.export_as_pdf_close()

  def return_stats(self):
    descr1 = self.df1.describe().T
    descr2 = self.df2.describe().T
    return descr1.compare(descr2, align_axis=0).rename(index={'self': 'set 1', 'other': 'set 2'}, level=-1).T
    
  def concpt_drift_twodfs(self, X1, X2, thrs=0.5):

    CV = StratifiedKFold(n_splits=self.n_splits, shuffle=True, random_state=self.seed)
    accuracies = []

    y = np.r_[np.ones((X1.shape[0],)),np.zeros((X2.shape[0],))]
    pred_oos = np.zeros_like(y)

    X = pd.concat([X1, X2], ignore_index=True, axis=0)
    
    for i,(id_train,id_test) in enumerate(CV.split(X,y)):
      model = self.base_model

      model.fit(X.iloc[id_train], y[id_train])
      
      pred_oos[id_test] = model.predict_proba(X.iloc[id_test])[:,1] 

      accuracies.append(accuracy_score(pred_oos[id_test]> thrs, y[id_test]))
      
    ks = ks_2samp(pred_oos[(y == 0)], pred_oos[(y == 1)])
      
    return round(ks.statistic, 4), round(ks.pvalue, 4), accuracies

  def concept_drift_detection(self):
    results = {}

    for column in self.df1.columns:
      ks_value, pvalue,accuracies = self.concpt_drift_twodfs(self.df1[[column]], self.df2[[column]])
      results[column] =  (ks_value, pvalue, np.array(accuracies).mean())

    results = pd.DataFrame.from_dict(results).T.reset_index()
    results.columns = ['variable','ks_value', 'pvalue', 'accuracies']
    return results

  def boxplot_custom(self, dict_values, label):
    pd.DataFrame(dict_values).plot.box(
        rot=90, figsize=(11,6), 
        medianprops=dict(linestyle='-', linewidth=1.8, c=self.colors[self.counter%4]), 
        patch_artist=True)
    plt.ylim([-0.05,1.05]); plt.ylabel(label)
    self.counter+=1

  def quantile_test(self, min_distinct=20, step=.2, test_size=0.3,  verbose=False):
    
    valid_features=[]
    for column in self.df1.columns:
      if len(self.df1[column].unique())>min_distinct:
        valid_features.append(column)
    
    if verbose:
      print('Checking columns (more than {} disctinct):{}'.format(min_distinct, valid_features))

    scores = {}
    accuracies_scores={}

    
    q_drifts = np.arange(0,1+step, step)
    CV = TimeSeriesSplit(n_splits=self.n_splits, test_size=test_size)

    for column in self.df1.columns:
      if column in valid_features:
        scores[column] =  {}
        accuracies_scores[column] =  {}
        for i_q in range(len(q_drifts)-1):
          x1 = self.df1[[column]].copy()
          x2 = self.df2[[column]].copy()

          x1 = x1[(x1[column] > x1[column].quantile(q_drifts[i_q])) & (x1[column] < x1[column].quantile(q_drifts[i_q+1]))]
          x2 = x2[(x2[column] > x2[column].quantile(q_drifts[i_q])) & (x2[column] < x2[column].quantile(q_drifts[i_q+1]))]
          ks_value, pvalue, accuracies = self.concpt_drift_twodfs(x1, x2)
          scores[column][round(q_drifts[i_q+1],2)] = ks_value
          accuracies_scores[column][round(q_drifts[i_q+1],2)] = np.array(accuracies).mean()


    self.boxplot_custom(scores, 'KS statistic')
    self.boxplot_custom(accuracies_scores, 'Accuracies')
    plt.hlines(0.5, xmin=1 , xmax=len(self.df1.columns), lw=1, color='black', linestyle='dashed')


    return scores, accuracies_scores